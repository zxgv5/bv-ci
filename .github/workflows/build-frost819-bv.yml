name: build-frost819-bv

on:
  workflow_dispatch:
  workflow_call:

env:
  JDK_VERSION: '21'
  ANDROID_COMPILE_SDK: '36'
  ANDROID_BUILD_TOOLS: '36.0.0'
  GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Clean runner environment
        run: |
          # 清理可能存在的全局缓存文件
          rm -rf ~/.gradle/caches/transforms-*
          rm -rf ~/.android/build-cache/

      - name: Checkout source repo (frost819-bv)
        uses: actions/checkout@main
        with:
          repository: Frost819/bv
          ref: feature
          path: frost819-bv-source
          fetch-depth: 0

      - name: Checkout pre-built libs repo (bv-libs)
        uses: actions/checkout@main
        with:
          repository: zxgv5/bv-libs
          ref: main
          path: bv-libs-source

      - name: Initialization values
        run: |
          echo "BUILD_DATE=$(TZ=UTC-8 date +"%y.%m.%d-%H.%M.%S")" >> $GITHUB_ENV

      - name: Merge libraries from monorepo structure
        run: |
          echo "=== 从 bv-libs Monorepo 复制各子库 ==="
          cd frost819-bv-source
          
          # 确保主项目的 libs 目录存在
          mkdir -p libs
          
          # 定义需要复制的库及其在bv-libs中的路径（与你提供的URL对应）
          declare -A LIB_PATHS
          LIB_PATHS=(
            ["av1Decoder"]="av1Decoder"
            ["ffmpegDecoder"]="ffmpegDecoder"
            ["libVLC"]="libVLC"
            ["media3Container"]="media3Container"
          )
          
          for LIB_NAME in "${!LIB_PATHS[@]}"; do
            SRC_PATH="../bv-libs-source/${LIB_PATHS[$LIB_NAME]}"
            DEST_PATH="libs/$LIB_NAME"
            
            echo "处理库: $LIB_NAME"
            echo "  源路径: $SRC_PATH"
            
            if [ -d "$SRC_PATH" ]; then
              # 删除目标目录，确保干净复制
              rm -rf "$DEST_PATH"
              # 复制整个库目录（包含 .aar 和 .kts 等所有文件）
              cp -r "$SRC_PATH" "$DEST_PATH"
              echo "  已复制到: $DEST_PATH"
              # 显示复制后的关键文件
              if [ -f "$DEST_PATH"/*.aar ]; then
                echo "  包含AAR文件: $(ls "$DEST_PATH"/*.aar | head -1 | xargs basename)"
              fi
            else
              echo "  错误：源路径不存在！"
              echo "  当前bv-libs-source目录内容:"
              ls -la "../bv-libs-source/" || true
              exit 1
            fi
            echo ""
          done
          
          echo "=== 合并完成，最终 libs/ 目录结构 ==="
          ls -la libs/

      - name: Cache gradle
        uses: actions/cache@main
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
            frost819-bv-source/.gradle
          key: ${{ runner.os }}-gradle-${{ hashFiles('frost819-bv-source/gradle/wrapper/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-
 
      - name: Set up jdk 21
        uses: actions/setup-java@main
        with:
          java-version: ${{ env.JDK_VERSION }}
          distribution: 'temurin'

      - name: Setup android sdk (minimal)
        uses: android-actions/setup-android@main
        with:
          api-level: ${{ env.ANDROID_COMPILE_SDK }}
          build-tools: ${{ env.ANDROID_BUILD_TOOLS }}
          accept-android-sdk-licenses: true

      - name: Fix app version calculation
        working-directory: ./frost819-bv-source
        run: |
          config_file="buildSrc/src/main/kotlin/AppConfiguration.kt"
          if [ -f "$config_file" ]; then
            echo "正在修改版本号计算规则 (git commit计数 + 1)..."
            sed -i.bak 's/"git rev-list --count HEAD".exec().toInt() - 5/"git rev-list --count HEAD".exec().toInt() + 1/' "$config_file"
            echo "修改后 versionCode 定义:"
            grep -A2 -B2 "versionCode.*by lazy" "$config_file"
          else
            echo "警告: 未找到 $config_file，跳过版本修改。"
          fi

      - name: Prepare gradle environment
        working-directory: ./frost819-bv-source
        run: |
          chmod +x gradlew
          echo "Gradle 版本信息:"
          ./gradlew --version

      # ========== 新增步骤：处理外部 AkDanmaku 依赖 ==========
      - name: Checkout and Build External AkDanmaku
        working-directory: ./
        run: |
          echo "=== 1. 克隆 AkDanmaku 源码 ==="
          # 使用深度克隆以加快速度
          git clone --depth 1 https://github.com/KwaiAppTeam/AkDanmaku.git akdanmaku-source
          
          echo "=== 2. 编译 AkDanmaku 为 AAR ==="
          cd akdanmaku-source
          chmod +x gradlew
          
          echo "尝试构建 AkDanmaku..."
          # 尝试通用的发布构建命令，如果失败则尝试指定模块
          if ./gradlew assembleRelease --no-daemon --stacktrace 2>&1; then
              echo "使用 'assembleRelease' 构建成功。"
          elif ./gradlew :akdanmaku:assembleRelease --no-daemon --stacktrace 2>&1; then
              echo "使用 ':akdanmaku:assembleRelease' 构建成功。"
          else
              echo "错误：未能成功构建 AkDanmaku。"
              echo "项目结构："
              find . -name "*.gradle*" -type f | head -10
              exit 1
          fi
          
          echo "=== 3. 定位并复制生成的 AAR 文件 ==="
          # 在构建输出目录中查找 AAR
          AAR_FILE=$(find . -name "*.aar" -path "*/release/*" 2>/dev/null | head -1)
          if [ -z "$AAR_FILE" ]; then
              # 如果没找到，尝试在其他常见位置查找
              AAR_FILE=$(find . -name "*.aar" 2>/dev/null | head -1)
          fi
          
          if [ -f "$AAR_FILE" ]; then
              echo "找到 AAR 文件: $AAR_FILE"
              # 在主项目内创建目录存放此 AAR
              mkdir -p ../frost819-bv-source/libs/akdanmakuExternal
              cp "$AAR_FILE" "../frost819-bv-source/libs/akdanmakuExternal/akdanmaku-release.aar"
              echo "已复制 AAR 到: ../frost819-bv-source/libs/akdanmakuExternal/"
          else
              echo "警告：未找到生成的 AAR 文件。依赖可能通过其他方式提供。"
              echo "构建输出目录内容："
              find . -type d -name "outputs" -exec ls -la {} \; 2>/dev/null || true
          fi

      - name: Integrate AkDanmaku into Main Project
        working-directory: ./frost819-bv-source
        run: |
          echo "=== 修改主项目依赖配置 ==="
          
          # 首先检查原始的依赖声明方式
          echo "检测对 'akdanmaku' 的依赖声明..."
          
          # 情况 1: 检测是否为项目模块依赖（implementation(project(":akdanmaku"))）
          if grep -q 'implementation(project(":akdanmaku"))' app/build.gradle.kts; then
              echo "发现源码模块依赖: implementation(project(\":akdanmaku\"))"
              echo "将为其添加备选的本地 AAR 依赖..."
              # 在 dependencies 块末尾添加 AAR 依赖
              if grep -q '^dependencies {' app/build.gradle.kts; then
                  # 在 dependencies 块闭合前插入
                  sed -i '/^dependencies {/,/^}/ { /^}/i\    // CI 集成的外部 AkDanmaku AAR\n    implementation(files("libs/akdanmakuExternal/akdanmaku-release.aar"))\n}' app/build.gradle.kts
              else
                  # 备用方案：直接在文件末尾添加
                  echo -e '\n// CI 集成的外部 AkDanmaku AAR\nimplementation(files("libs/akdanmakuExternal/akdanmaku-release.aar"))' >> app/build.gradle.kts
              fi
          fi
          
          # 情况 2: 检测是否为版本目录别名依赖（implementation(libs.akdanmaku)）
          if grep -q 'implementation(libs\.akdanmaku)' app/build.gradle.kts; then
              echo "发现版本目录依赖: implementation(libs.akdanmaku)"
              echo "将添加本地 AAR 依赖作为首要选择..."
              # 在原有依赖行之前插入 AAR 依赖
              sed -i '/implementation(libs\.akdanmaku)/i\    implementation(files("libs/akdanmakuExternal/akdanmaku-release.aar")) // CI 集成版本' app/build.gradle.kts
          fi
          
          # 如果以上均未匹配，但存在 libs/akdanmakuExternal 目录，则主动添加依赖
          if [ -d "libs/akdanmakuExternal" ] && [ -f "libs/akdanmakuExternal/akdanmaku-release.aar" ]; then
              if ! grep -q 'akdanmakuExternal/akdanmaku-release.aar' app/build.gradle.kts; then
                  echo "未检测到显式的 akdanmaku 依赖，但存在 AAR 文件，正在添加..."
                  echo -e '\n// CI 集成的外部 AkDanmaku AAR\nimplementation(files("libs/akdanmakuExternal/akdanmaku-release.aar"))' >> app/build.gradle.kts
              fi
          fi
          
          echo "修改后的依赖相关部分预览："
          grep -n -A2 -B2 "akdanmaku" app/build.gradle.kts || echo "（未找到 'akdanmaku' 关键字）"
          
          echo "当前 libs/ 目录内容："
          ls -la libs/ || echo "libs/ 目录不存在"

      # ========== 继续原有步骤 ==========
      - name: Decode and write release keystore
        working-directory: ./frost819-bv-source
        run: |
          echo "${{ secrets.KEYSTORE_BASE64 }}" | base64 -d > keystore.p12
          # 同时，创建一个虚拟的debug密钥库文件（例如，直接复制一份release的，或创建一个空文件）
          # 这里选择复制，以确保它是一个有效的文件
          cp keystore.p12 debug.keystore
      
      - name: Write signing.properties for release build
        working-directory: ./frost819-bv-source
        run: |
          cat <<EOF > signing.properties
          # 1. 提供真实且有效的RELEASE签名配置（用于最终的APK签名）
          releaseStoreFile=keystore.p12
          releaseKeyAlias=${{ secrets.KEY_ALIAS }}
          releaseStorePassword=${{ secrets.KEYSTORE_PASSWORD }}
          releaseKeyPassword=${{ secrets.KEY_ALIAS_PASSWORD }}
      
          # 2. 提供虚拟但有效的DEBUG签名配置（仅用于绕过脚本检查）
          debugStoreFile=debug.keystore
          debugKeyAlias=androiddebugkey
          debugStorePassword=android
          debugKeyPassword=android
          EOF

      - name: Build release apk files
        working-directory: ./frost819-bv-source
        run: |
          echo "=== 开始构建 (已集成外部 AkDanmaku) ==="
          ./gradlew :app:assembleRelease --no-daemon --stacktrace
          
          echo ""
          echo "=== 构建完成！查找APK产物 ==="
          find . -name "*.apk" -type f | grep -i release | while read apk; do
            echo "  $(ls -lh "$apk")"
          done || echo "未找到APK文件，请检查构建日志。"
          
          mv "./app/build/outputs/apk/default/release/"*.apk "./app/build/outputs/apk/default/release/f819bv-${{ env.BUILD_DATE }}.apk" 2>/dev/null || echo "移动APK文件失败，可能文件名不匹配。"
 
      - name: Create github release & upload apk
        uses: softprops/action-gh-release@master
        with:
          tag_name: ${{env.BUILD_DATE}}-f819bv
          # tag_name: latest-release
          # 要附加到此次发布的文件列表
          files: |
            frost819-bv-source/app/build/outputs/apk/default/release/f819bv-${{ env.BUILD_DATE }}.apk
            # frost819-bv-source/app/build/outputs/apk/default/release/*.apk
          # 设置为 true 则每次运行覆盖同名草稿，适用于持续集成测试版
          draft: false
          # 是否为预发布版本
          prerelease: false
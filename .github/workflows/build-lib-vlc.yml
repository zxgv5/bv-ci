name: build-lib-vlc

on:
  workflow_dispatch:
  workflow_call:

env:
  SOURCE_REPO: 'https://github.com/videolan/vlc-android.git'
  # SOURCE_BRANCH: 'libvlc-3.6.5'
  SOURCE_BRANCH: 'master'
  BUILD_DIR: 'vlc-android-source'
  GRADLE_VERSION: '8.13'

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Clean runner environment
        run: |
          rm -rf ~/.gradle/caches/transforms-*
          rm -rf ~/.android/build-cache/
          
      - name: Checkout ci repo
        uses: actions/checkout@main

      - name: Initialization values
        run: |
          echo "BUILD_DATE=$(TZ=UTC-8 date +"%y.%m.%d-%H.%M.%S")" >> $GITHUB_ENV

      - name: Clone source repository
        run: |
          echo "Cloning source repository..."
          # 使用更彻底的清理，避免残留文件导致问题
          rm -rf "${{ env.BUILD_DIR }}"
          git clone --depth 1 --branch "${{ env.SOURCE_BRANCH }}" "${{ env.SOURCE_REPO }}" "${{ env.BUILD_DIR }}"




      - name: Setup java 17
        uses: actions/setup-java@main
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: 'gradle'

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            automake autopoint cmake build-essential libtool \
            patch pkg-config ragel subversion unzip git \
            flex python3 python3-pip wget ninja-build meson nasm yasm \
            libssl-dev protobuf-compiler gettext

      - name: Configure android environment and project
        run: |
          cd "${{ env.BUILD_DIR }}"
          echo "=== 配置 Android 构建环境 ==="
          
          # 1. 验证安装的 NDK 版本和路径
          echo "检查 NDK 安装:"
          if [ -n "$ANDROID_NDK_ROOT" ]; then
            echo "ANDROID_NDK_ROOT: $ANDROID_NDK_ROOT"
            ls -la $ANDROID_NDK_ROOT/ || echo "无法列出 NDK 目录"
            # 检查 ndk-build 版本
            if [ -f "$ANDROID_NDK_ROOT/ndk-build" ]; then
              echo "NDK-Build 版本信息:"
              $ANDROID_NDK_ROOT/ndk-build --version | head -5 || echo "无法获取 ndk-build 版本"
            fi
          else
            echo "警告: ANDROID_NDK_ROOT 未设置"
            # 尝试推断常见路径
            if [ -d "$ANDROID_HOME/ndk" ]; then
              export ANDROID_NDK_ROOT="$(find $ANDROID_HOME/ndk -maxdepth 1 -type d | head -2 | tail -1)"
              echo "推断 ANDROID_NDK_ROOT 为: $ANDROID_NDK_ROOT"
            fi
          fi

          # 2. 配置 Git 身份（解决之前的补丁应用问题）
          git config --global user.email "ci@github-actions"
          git config --global user.name "GitHub Actions"
          
          # 3. 确保脚本所需的环境变量（关键）
          # actions/setup-android 设置的是 ANDROID_NDK_ROOT，但 VLC 脚本可能期望 ANDROID_NDK
          export ANDROID_SDK="$ANDROID_SDK_ROOT"
          export ANDROID_NDK="$ANDROID_NDK_ROOT"
          echo "导出编译变量:"
          echo "  ANDROID_SDK=$ANDROID_SDK"
          echo "  ANDROID_NDK=$ANDROID_NDK"
          
          # 4. 创建 Gradle 的 local.properties
          echo "sdk.dir=$ANDROID_SDK_ROOT" > local.properties
          echo "ndk.dir=$ANDROID_NDK_ROOT" >> local.properties
          echo "✅ 创建 local.properties"
          
          # 5. 初始化 Gradle wrapper
          ./gradlew wrapper --gradle-version=${{ env.GRADLE_VERSION }} --distribution-type=all --quiet 2>/dev/null || true
          
          echo "✅ 环境配置完成"
    
    # 始终用最新的vlc源码(https://code.videolan.org/videolan/vlc.git)，即master分支，而非get-vlc.sh中指定的VLC_TESTED_HASH对应的提交
    - name: Patch get-vlc.sh to always use latest vlc source
      run: |
        cd "${{ env.BUILD_DIR }}"
        
        # 找到 get-vlc.sh 脚本，通常在 libvlcjni/buildsystem/ 目录
        GET_VLC_SCRIPT="libvlcjni/buildsystem/get-vlc.sh"
        if [ ! -f "$GET_VLC_SCRIPT" ]; then
          # 也可能在 buildsystem/ 根目录
          GET_VLC_SCRIPT="buildsystem/get-vlc.sh"
        fi
        
        if [ -f "$GET_VLC_SCRIPT" ]; then
          echo "找到并修改脚本: $GET_VLC_SCRIPT"
          # 备份原脚本
          cp "$GET_VLC_SCRIPT" "$GET_VLC_SCRIPT.backup"
          
          # 方案一（推荐）：注释掉重置到特定哈希的命令行
          # 这会让脚本克隆后停留在最新的 master 分支上
          sed -i 's/git reset --hard ${VLC_TESTED_HASH}/# &/' "$GET_VLC_SCRIPT"
          # 同时注释掉后续的哈希检查和补丁验证（如果不需要）
          # sed -i 's/check_patch_is_applied/# &/' "$GET_VLC_SCRIPT"
          
          echo "✅ 已修改脚本，将使用最新 master 分支代码。"
        else
          echo "⚠️  警告：未找到 get-vlc.sh 脚本，将使用默认流程。"
        fi

      # 手动获取并修改vlc源代码
      - name: Get and modify vlc source code
        run: |
          cd "${{ env.BUILD_DIR }}"
          
          echo "=== 手动获取VLC源代码 ==="
          
          # 检查libvlcjni目录是否存在
          if [ ! -d "libvlcjni" ]; then
            echo "libvlcjni目录不存在，创建..."
            # 从clone的源码中查找或创建
            if [ -d "libvlc" ]; then
              mv libvlc libvlcjni
            else
              mkdir -p libvlcjni
            fi
          fi
          
          # 手动运行get-vlc.sh来获取VLC核心代码
          echo "运行get-vlc.sh获取VLC核心代码..."
          if [ -f "libvlcjni/buildsystem/get-vlc.sh" ]; then
            (cd libvlcjni && ./buildsystem/get-vlc.sh)
          elif [ -f "buildsystem/get-vlc.sh" ]; then
            ./buildsystem/get-vlc.sh
          else
            echo "get-vlc.sh未找到，手动克隆VLC..."
            git clone --depth 1 https://code.videolan.org/videolan/vlc.git libvlcjni/vlc
          fi
          
          # 确认VLC源代码已获取
          if [ ! -d "libvlcjni/vlc" ]; then
            echo "❌ VLC源代码目录不存在"
            exit 1
          fi
          
          VLC_SRC_DIR="libvlcjni/vlc"
          echo "VLC源代码位于: $VLC_SRC_DIR"
          
          # 查看当前VLC版本
          echo "=== 当前VLC版本信息 ==="
          (cd "$VLC_SRC_DIR" && git log --oneline -1) || echo "无法获取git信息"
          
          echo "=== 开始修改VLC源代码 ==="
          
          # 1. 修改 /lib/core.c
          echo "1. 修改 /lib/core.c..."
          CORE_FILE="$VLC_SRC_DIR/lib/core.c"
          if [ -f "$CORE_FILE" ]; then
            # 备份原文件
            cp "$CORE_FILE" "${CORE_FILE}.backup"
            # 使用精确的sed命令
            sed -i 's/&& (asprintf (\&str, "%s LibVLC\/"PACKAGE_VERSION, http) != -1))/&& (asprintf (\&str, "%s abc_media_editor", http) != -1))/' "$CORE_FILE"
            
            # 验证修改
            if grep -q "abc_media_editor" "$CORE_FILE"; then
              echo "✅ /lib/core.c 修改成功"
            else
              echo "⚠️  /lib/core.c 可能未成功修改"
              # 显示修改前后的对比
              echo "修改前的行:"
              grep -n "LibVLC/" "${CORE_FILE}.backup" | head -2
              echo "修改后的行:"
              grep -n "abc_media_editor" "$CORE_FILE" || echo "未找到abc_media_editor"
            fi
          else
            echo "❌ 文件不存在: $CORE_FILE"
          fi
          
          # 2. 修改 /src/libvlc.c - 第一处
          echo -e "\n2. 修改 /src/libvlc.c - 第一处..."
          LIBVLC_FILE="$VLC_SRC_DIR/src/libvlc.c"
          if [ -f "$LIBVLC_FILE" ]; then
            # 备份原文件
            cp "$LIBVLC_FILE" "${LIBVLC_FILE}.backup"
            # 第一处修改
            sed -i 's/"VLC media player (LibVLC "VERSION")"/"abc media editor"/' "$LIBVLC_FILE"
            
            # 验证第一处修改
            if grep -q '"abc media editor"' "$LIBVLC_FILE"; then
              echo "✅ /src/libvlc.c 第一处修改成功"
            else
              echo "⚠️  /src/libvlc.c 第一处可能未成功修改"
            fi
          else
            echo "❌ 文件不存在: $LIBVLC_FILE"
          fi
          
          # 3. 修改 /src/libvlc.c - 第二处
          echo -e "\n3. 修改 /src/libvlc.c - 第二处..."
          if [ -f "$LIBVLC_FILE" ]; then
            # 第二处修改
            sed -i 's/"VLC\/"PACKAGE_VERSION" LibVLC\/"PACKAGE_VERSION/"abc\/abc_media_editor\/"/' "$LIBVLC_FILE"
            
            # 验证第二处修改
            if grep -q '"abc/abc_media_editor/"' "$LIBVLC_FILE"; then
              echo "✅ /src/libvlc.c 第二处修改成功"
            else
              echo "⚠️  /src/libvlc.c 第二处可能未成功修改"
            fi
          fi
          
          # 4. 修改 /modules/access/live555.cpp
          echo -e "\n4. 修改 /modules/access/live555.cpp..."
          LIVE555_FILE="$VLC_SRC_DIR/modules/access/live555.cpp"
          if [ -f "$LIVE555_FILE" ]; then
            # 备份原文件
            cp "$LIVE555_FILE" "${LIVE555_FILE}.backup"
            # 修改
            sed -i 's/"LibVLC\/" VERSION/"abc_media_editor"/' "$LIVE555_FILE"
            
            # 验证修改
            if grep -q '"abc_media_editor"' "$LIVE555_FILE"; then
              echo "✅ /modules/access/live555.cpp 修改成功"
            else
              echo "⚠️  /modules/access/live555.cpp 可能未成功修改"
            fi
          else
            echo "❌ 文件不存在: $LIVE555_FILE"
          fi
          
          # 最终验证
          echo -e "\n=== 修改结果验证 ==="
          echo "修改的文件列表:"
          find "$VLC_SRC_DIR" -name "*.backup" -type f | sed 's/.backup$//' | while read file; do
            echo "  - $file"
          done
          
          echo -e "\n修改内容摘要:"
          for file in "$CORE_FILE" "$LIBVLC_FILE" "$LIVE555_FILE"; do
            if [ -f "$file" ]; then
              echo "=== $(basename "$file") ==="
              grep -n "abc_media_editor\|abc media editor" "$file" || echo "  未找到自定义字符串"
            fi
          done
          
          echo -e "\n✅ VLC源代码修改完成"

      # 修改构建步骤，添加-b参数跳过源码检查
      - name: Build libvlc for arm64-v8a
        run: |
          cd "${{ env.BUILD_DIR }}"
          echo "开始构建 ARM64 (arm64-v8a) 架构..."
          
          export ANDROID_SDK="$ANDROID_SDK_ROOT"
          export ANDROID_NDK="$ANDROID_NDK_ROOT"
          
          # 添加-b参数跳过VLC源码检查（因为我们已经手动修改了）
          time ./buildsystem/compile.sh -l -a arm64 --release -t -b 2>&1 | tee build_arm64.log
          
          # 检查构建结果
          if ls libvlcjni/libvlc/build/outputs/aar/*.aar 1> /dev/null 2>&1; then
            echo "✅ ARM64 AAR 构建成功！"
            cp libvlcjni/libvlc/build/outputs/aar/*.aar ../libvlc-arm64.aar
          else
            echo "⚠️  未找到ARM64 AAR文件。查看构建日志末尾:"
            tail -100 build_arm64.log
            exit 1 # 使步骤失败
          fi

      - name: Download and setup ndk r21 for armeabi-v7a build need
        run: |
          # 1. 创建 NDK 目录
          mkdir -p $ANDROID_SDK_ROOT/ndk
          # 2. 下载官方 NDK r21 (以 Linux 64位为例)
          wget -q https://dl.google.com/android/repository/android-ndk-r21e-linux-x86_64.zip
          # 3. 解压到 SDK 的 ndk 目录下，并重命名为固定路径
          unzip -q android-ndk-r21e-linux-x86_64.zip -d $ANDROID_SDK_ROOT/ndk/
          mv $ANDROID_SDK_ROOT/ndk/android-ndk-r21e $ANDROID_SDK_ROOT/ndk/21.0.0
          # 4. 设置环境变量（后续步骤和 compile.sh 都需要）
          echo "ANDROID_NDK=$ANDROID_SDK_ROOT/ndk/21.0.0" >> $GITHUB_ENV
          echo "NDK_ROOT=$ANDROID_SDK_ROOT/ndk/21.0.0" >> $GITHUB_ENV

      - name: Build libvlc for armeabi-v7a
        run: |
          cd "${{ env.BUILD_DIR }}"
          echo "清理前一次构建的中间产物..."
          rm -rf libvlcjni/libvlc/build/outputs/aar/*.aar 2>/dev/null || true

          echo "检查当前 NDK 环境..."
          # 备份并移除可能冲突的 NDK
          if [ -d "$ANDROID_SDK_ROOT/ndk-bundle" ]; then
            echo "发现 ndk-bundle，可能引起冲突，重命名..."
            mv "$ANDROID_SDK_ROOT/ndk-bundle" "$ANDROID_SDK_ROOT/ndk-bundle.backup"
          fi

          # 设置正确的环境变量 - 这是关键！
          export ANDROID_NDK="${{ env.ANDROID_NDK }}"
          export ANDROID_SDK="$ANDROID_SDK_ROOT"
          export ANDROID_NDK_ROOT="${{ env.ANDROID_NDK }}"
          export ANDROID_SDK_ROOT="$ANDROID_SDK_ROOT"
    
          # 打印环境变量用于调试
          echo "=== 环境变量检查 ==="
          echo "ANDROID_NDK: $ANDROID_NDK"
          echo "ANDROID_SDK: $ANDROID_SDK"
          echo "ANDROID_NDK_ROOT: $ANDROID_NDK_ROOT"
          echo "ANDROID_SDK_ROOT: $ANDROID_SDK_ROOT"

          # 验证使用的 NDK
          echo "使用的 NDK 路径: $ANDROID_NDK"
          $ANDROID_NDK/ndk-build --version | head -5

          # 更新 local.properties
          echo "sdk.dir=$ANDROID_SDK_ROOT" > local.properties
          echo "ndk.dir=$ANDROID_NDK" >> local.properties

          echo "开始构建 ARMv7 (armeabi-v7a) 架构..."
          # 先检查脚本是否存在
          if [ ! -f "./buildsystem/compile.sh" ]; then
            echo "错误: compile.sh 脚本不存在！"
            exit 1
          fi
    
          # 给脚本添加执行权限
          chmod +x ./buildsystem/compile.sh
    
          # 在命令行中直接传递环境变量
          time ANDROID_NDK="$ANDROID_NDK" ANDROID_SDK="$ANDROID_SDK" \
              ./buildsystem/compile.sh -l -a arm --release -t -b 2>&1 | tee build_armv7.log

          if ls libvlcjni/libvlc/build/outputs/aar/*.aar 1> /dev/null 2>&1; then
            echo "✅ ARMv7 AAR 构建成功！"
            cp libvlcjni/libvlc/build/outputs/aar/*.aar ../libvlc-armv7.aar
          else
            echo "❌ 未找到ARMv7 AAR文件。关键错误如下:"
            grep -A 10 -B 5 -i "error\|failed\|ndk\|could not\|v21 needed" build_armv7.log | head -100
            exit 1
          fi

      - name: Merge aars and verify
        if: always() # 即使上一步有警告也继续执行
        run: |
          echo "准备合并AAR文件..."
          cd "${{ env.BUILD_DIR }}"
          
          # 查找所有可能生成的AAR文件
          find . -name "*.aar" -type f -exec cp {} ../ \;
          cd ..
          
          echo "找到的AAR文件："
          ls -la *.aar 2>/dev/null || { echo "未找到任何AAR文件，构建可能失败。"; exit 1; }
          
          # 智能合并：自动识别基础包和架构包
          /bin/bash -c '
          aars=(*.aar)
          if [ ${#aars[@]} -lt 1 ]; then
              exit 1
          fi
          # 尝试找到一个包含“all”或版本号最全的作为基础包
          BASE_AAR=""
          for aar in "${aars[@]}"; do
              if [[ "$aar" == *"all"* ]] || [[ "$aar" == *"release"* ]]; then
                  BASE_AAR="$aar"
                  break
              fi
          done
          if [ -z "$BASE_AAR" ]; then
              BASE_AAR="${aars[0]}"
          fi
          
          echo "使用 $BASE_AAR 作为基础包进行合并"
          mkdir -p merged-aar
          unzip -q "$BASE_AAR" -d merged-aar
          
          for aar in "${aars[@]}"; do
              if [ "$aar" != "$BASE_AAR" ]; then
                  echo "合并架构库从: $aar"
                  unzip -q -u "$aar" -d merged-aar 2>/dev/null || true
              fi
          done
          
          cd merged-aar
          zip -qr ../libvlc-release.aar .
          cd ..
          
          echo "✅ 合并完成！最终产物: libvlc-release.aar"
          echo "包含的架构:"
          unzip -l libvlc-release.aar | grep "jni/.*/" | cut -d"/" -f2 | sort -u || echo "无法列出架构"
          '

      - name: Create github release
        uses: softprops/action-gh-release@master
        with:
          tag_name: ${{env.BUILD_DATE}}-vlclib
          files: |
            libvlc-release.aar
            libvlc-arm64.aar
            libvlc-armv7.aar
          draft: false
          prerelease: false

      - name: Push vlc aar to bv-libs repository
        env:
          TARGET_REPO: "git@github.com:zxgv5/bv-libs.git"
        run: |
          # 设置 SSH 密钥和配置
          echo "Setting up SSH configuration..."
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # 写入私钥
          echo "${{ secrets.BV_LIBS_DEPLOY_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          
          # 配置 SSH 不验证主机
          echo "Host github.com" >> ~/.ssh/config
          echo "  StrictHostKeyChecking no" >> ~/.ssh/config
          echo "  UserKnownHostsFile /dev/null" >> ~/.ssh/config
          chmod 600 ~/.ssh/config
          
          # 测试 SSH 连接
          echo "Testing SSH connection to GitHub..."
          ssh -T git@github.com 2>&1 | grep -v "successfully authenticated" || true
          
          # 设置 Git 配置
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git config --global init.defaultBranch main
          
          # 克隆目标仓库
          cd "$GITHUB_WORKSPACE"
          echo "Cloning target repository: ${{ env.TARGET_REPO }}"
          git clone ${{ env.TARGET_REPO }} target-repo
          cd target-repo
          
          # 确保在 main 分支
          git checkout main
          
          # 复制新的 AAR 文件到目标位置
          SOURCE_AAR="$GITHUB_WORKSPACE/libvlc-release.aar"
          TARGET_DIR="libVLC"
          
          # 检查 AAR 文件是否存在
          if [ -f "$SOURCE_AAR" ]; then
            echo "✓ Found AAR file: $SOURCE_AAR"
            
            # 确保目标目录存在
            mkdir -p "$TARGET_DIR"
            
            # 复制新文件
            echo "Copying new AAR file..."
            cp -v "$SOURCE_AAR" "$TARGET_DIR/libvlc-release.aar"
            
            # 提交更改
            echo "Committing changes..."
            git add "$TARGET_DIR/libvlc-release.aar"
            
            # 检查是否有更改
            if git diff --cached --quiet; then
              echo "No changes to commit."
            else
              git commit -m "Update VLC AAR (multi-arch: arm64+v7a) - ${{ env.BUILD_DATE }} [CI]"
              echo "Pushing to remote repository..."
              git push origin main
              echo "✓ Successfully pushed multi-architecture VLC AAR to ${{ env.TARGET_REPO }}"
            fi
          else
            echo "✗ Error: AAR file not found at $SOURCE_AAR"
            exit 1
          fi
          
          # 清理 SSH 密钥
          rm -f ~/.ssh/id_ed25519
          rm -f ~/.ssh/config

      # 可选：缓存构建结果以加速后续构建
      # - name: Cache build artifacts
      #   uses: actions/cache@main
      #   with:
      #     path: |
      #       ~/.gradle/caches
      #       ~/.gradle/wrapper
      #       vlc-android/.gradle
      #       vlc-android/libvlcjni/vlc/contrib
      #     key: ${{ runner.os }}-vlc-build-${{ hashFiles('vlc-android/compile.sh', 'vlc-android/build.gradle') }}
      #     restore-keys: |
      #       ${{ runner.os }}-vlc-build-
name: build-lib-vlc

on:
  workflow_dispatch:
  workflow_call:

env:
  SOURCE_REPO: 'https://github.com/videolan/vlc-android.git'
  SOURCE_BRANCH: 'master'
  BUILD_DIR: 'vlc-android-source'
  GRADLE_VERSION: '8.13'

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Clean runner environment
        run: |
          rm -rf ~/.gradle/caches/transforms-*
          rm -rf ~/.android/build-cache/
          
      - name: Checkout ci repo
        uses: actions/checkout@main

      - name: Initialization values
        run: |
          echo "BUILD_DATE=$(TZ=UTC-8 date +"%y.%m.%d-%H.%M.%S")" >> $GITHUB_ENV

      - name: Clone source repository
        run: |
          echo "Cloning source repository..."
          rm -rf "${{ env.BUILD_DIR }}"
          git clone --depth 1 --branch "${{ env.SOURCE_BRANCH }}" "${{ env.SOURCE_REPO }}" "${{ env.BUILD_DIR }}"

      - name: Setup java 17
        uses: actions/setup-java@main
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: 'gradle'

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            automake autopoint cmake build-essential libtool \
            patch pkg-config ragel subversion unzip git \
            flex python3 python3-pip wget ninja-build meson nasm yasm \
            libssl-dev protobuf-compiler gettext

      - name: Configure android environment and project
        run: |
          cd "${{ env.BUILD_DIR }}"
          echo "=== 配置 Android 构建环境 ==="
          
          # 设置Git身份
          git config --global user.email "ci@github-actions"
          git config --global user.name "GitHub Actions"
          
          # 导出编译变量
          export ANDROID_SDK="$ANDROID_SDK_ROOT"
          export ANDROID_NDK="$ANDROID_NDK_ROOT"
          echo "导出编译变量:"
          echo "  ANDROID_SDK=$ANDROID_SDK"
          echo "  ANDROID_NDK=$ANDROID_NDK"
          
          # 创建 Gradle 的 local.properties
          echo "sdk.dir=$ANDROID_SDK_ROOT" > local.properties
          echo "ndk.dir=$ANDROID_NDK_ROOT" >> local.properties
          echo "✅ 创建 local.properties"
          
          # 初始化 Gradle wrapper
          ./gradlew wrapper --gradle-version=${{ env.GRADLE_VERSION }} --distribution-type=all --quiet 2>/dev/null || true
          
          echo "✅ 环境配置完成"

      # 替换修改源代码的步骤
      
      - name: Modify vlc source code correctly
        run: |
          cd "${{ env.BUILD_DIR }}"
          
          echo "=== 正确修改VLC源代码 ==="
          
          # 等待VLC源代码被获取（第一次构建时会获取）
          echo "等待VLC源代码..."
          
          # 如果还没有VLC源代码，先触发获取
          if [ ! -d "libvlcjni/vlc" ]; then
            echo "VLC源代码不存在，触发获取..."
            # 运行简化的构建初始化
            if [ -f "./buildsystem/compile.sh" ]; then
              chmod +x ./buildsystem/compile.sh
              # 只初始化不构建
              ./buildsystem/compile.sh --init 2>&1 | tail -20 || echo "初始化完成"
            fi
          fi
          
          # 等待一段时间
          sleep 10
          
          if [ ! -d "libvlcjni/vlc" ]; then
            echo "手动克隆VLC源代码..."
            mkdir -p libvlcjni
            git clone --depth 1 https://code.videolan.org/videolan/vlc.git libvlcjni/vlc
          fi
          
          VLC_SRC_DIR="libvlcjni/vlc"
          echo "VLC源代码目录: $VLC_SRC_DIR"
          
          # 使用Python脚本进行稳健的修改
          cat > modify_vlc.py << 'EOF'
                                 #!/usr/bin/env python3
                                 import os
                                 import re
                                 import sys
                                 def modify_file(filepath, patterns):
                                     """修改文件内容"""
                                     if not os.path.exists(filepath):
                                         print(f"文件不存在: {filepath}")
                                         return False
                                     with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                                         content = f.read()
                                     original_content = content
                                     
                                     for pattern, replacement in patterns:
                                         content = re.sub(pattern, replacement, content)
                                     
                                     if content != original_content:
                                         with open(filepath, 'w', encoding='utf-8') as f:
                                             f.write(content)
                                         print(f"✅ 已修改: {filepath}")
                                         return True
                                     else:
                                         print(f"⚠️  未修改: {filepath} (未找到匹配模式)")
                                         return False
                                 # 要修改的文件和模式
                                 modifications = [
                                     # core.c: 修改User-Agent字符串
                                     (
                                         r'lib/core\.c',
                                         [
                                             # 匹配: && (asprintf (&str, "%s LibVLC/"PACKAGE_VERSION, http) != -1))
                                             # 替换: && (asprintf (&str, "%s abc_media_editor", http) != -1))
                                             (r'\(asprintf\s*\(\s*&str\s*,\s*"%s\s+LibVLC/"PACKAGE_VERSION\s*,\s*http\s*\)\s*!=\s*-1\s*\)',
                                              r'(asprintf (&str, "%s abc_media_editor", http) != -1)')
                                         ]
                                     ),
                                     # libvlc.c: 第一处
                                     (
                                         r'src/libvlc\.c',
                                         [
                                             # 匹配: "VLC media player (LibVLC "VERSION")"
                                             # 替换: "abc media editor"
                                             (r'"VLC media player \(LibVLC "VERSION"\)"',
                                              r'"abc media editor"')
                                         ]
                                     ),
                                     # libvlc.c: 第二处
                                     (
                                         r'src/libvlc\.c',
                                         [
                                             # 匹配: "VLC/"PACKAGE_VERSION" LibVLC/"PACKAGE_VERSION
                                             # 替换: "abc/abc_media_editor/"
                                             (r'"VLC/"PACKAGE_VERSION"\s+LibVLC/"PACKAGE_VERSION',
                                              r'"abc/abc_media_editor/"')
                                         ]
                                     ),
                                     # live555.cpp
                                     (
                                         r'modules/access/live555\.cpp',
                                         [
                                             # 匹配: "LibVLC/" VERSION
                                             # 替换: "abc_media_editor"
                                             (r'"LibVLC/"\s+VERSION',
                                              r'"abc_media_editor"')
                                         ]
                                     )
                                 ]
                                 vlc_dir = sys.argv[1] if len(sys.argv) > 1 else "."
                                 for file_pattern, patterns in modifications:
                                     # 查找文件
                                     for root, dirs, files in os.walk(vlc_dir):
                                         for file in files:
                                             if re.search(file_pattern, os.path.join(root, file)):
                                                 filepath = os.path.join(root, file)
                                                 modify_file(filepath, patterns)
                                                 break
                                 print("✅ 修改完成")
                                 EOF
          # 执行Python脚本
          python3 modify_vlc.py "$VLC_SRC_DIR"
          # 验证修改
          echo "=== 验证修改 ==="
          # core.c 验证
          CORE_FILE="$VLC_SRC_DIR/lib/core.c"
          if [ -f "$CORE_FILE" ]; then
            echo "检查 core.c:"
            if grep -q '"%s abc_media_editor"' "$CORE_FILE"; then
              echo "✅ core.c 修改成功"
              # 显示修改的行
              grep -n '"%s abc_media_editor"' "$CORE_FILE"
            else
              echo "❌ core.c 修改失败"
              # 显示原始行
              grep -n 'asprintf.*&str' "$CORE_FILE" | head -5
            fi
          fi
          # libvlc.c 验证
          LIBVLC_FILE="$VLC_SRC_DIR/src/libvlc.c"
          if [ -f "$LIBVLC_FILE" ]; then
            echo -e "\n检查 libvlc.c:"
            if grep -q '"abc media editor"' "$LIBVLC_FILE"; then
              echo "✅ 第一处修改成功"
            else
              echo "❌ 第一处修改失败"
            fi
            if grep -q '"abc/abc_media_editor/"' "$LIBVLC_FILE"; then
              echo "✅ 第二处修改成功"
            else
              echo "❌ 第二处修改失败"
            fi
          fi
          # live555.cpp 验证
          LIVE555_FILE="$VLC_SRC_DIR/modules/access/live555.cpp"
          if [ -f "$LIVE555_FILE" ]; then
            echo -e "\n检查 live555.cpp:"
            if grep -q '"abc_media_editor"' "$LIVE555_FILE"; then
              echo "✅ 修改成功"
            else
              echo "❌ 修改失败"
            fi
          fi
          echo "✅ VLC源代码修改完成"

      # 修改arm64-v8a构建步骤，确保使用修改后的代码
      - name: Build libvlc for arm64-v8a
        run: |
          cd "${{ env.BUILD_DIR }}"
          echo "开始构建 ARM64 (arm64-v8a) 架构..."
          
          export ANDROID_SDK="$ANDROID_SDK_ROOT"
          export ANDROID_NDK="$ANDROID_NDK_ROOT"
          
          # 清理之前的构建缓存，确保使用修改后的代码
          echo "清理构建缓存..."
          rm -rf libvlcjni/vlc/build-android-aarch64-linux-android 2>/dev/null || true
          
          # 使用-b参数跳过源码检查
          time ./buildsystem/compile.sh -l -a arm64 --release -t -b 2>&1 | tee build_arm64.log
          
          # 检查构建结果
          if ls libvlcjni/libvlc/build/outputs/aar/*.aar 1> /dev/null 2>&1; then
            echo "✅ ARM64 AAR 构建成功！"
            cp libvlcjni/libvlc/build/outputs/aar/*.aar ../libvlc-arm64.aar
          else
            echo "⚠️  未找到ARM64 AAR文件。查看构建日志末尾:"
            tail -100 build_arm64.log
            exit 1
          fi

      - name: Download and setup ndk r21 for armeabi-v7a build need
        run: |
          # 创建 NDK 目录
          mkdir -p $ANDROID_SDK_ROOT/ndk
          # 下载官方 NDK r21
          wget -q https://dl.google.com/android/repository/android-ndk-r21e-linux-x86_64.zip
          # 解压到 SDK 的 ndk 目录下
          unzip -q android-ndk-r21e-linux-x86_64.zip -d $ANDROID_SDK_ROOT/ndk/
          mv $ANDROID_SDK_ROOT/ndk/android-ndk-r21e $ANDROID_SDK_ROOT/ndk/21.0.0
          # 设置环境变量
          echo "ANDROID_NDK=$ANDROID_SDK_ROOT/ndk/21.0.0" >> $GITHUB_ENV
          echo "NDK_ROOT=$ANDROID_SDK_ROOT/ndk/21.0.0" >> $GITHUB_ENV

      # 修改armv7构建步骤
      - name: Build libvlc for armeabi-v7a
        run: |
          cd "${{ env.BUILD_DIR }}"
          echo "清理前一次构建的中间产物..."
          
          # 只清理aar文件，不清理源代码
          rm -rf libvlcjni/libvlc/build/outputs/aar/*.aar 2>/dev/null || true
          # 清理armeabi-v7a的构建目录
          rm -rf libvlcjni/vlc/build-android-arm-linux-androideabi 2>/dev/null || true
      
          echo "检查当前 NDK 环境..."
          # 备份并移除可能冲突的 NDK
          if [ -d "$ANDROID_SDK_ROOT/ndk-bundle" ]; then
            echo "发现 ndk-bundle，可能引起冲突，重命名..."
            mv "$ANDROID_SDK_ROOT/ndk-bundle" "$ANDROID_SDK_ROOT/ndk-bundle.backup"
          fi
      
          # 设置正确的环境变量
          export ANDROID_NDK="${{ env.ANDROID_NDK }}"
          export ANDROID_SDK="$ANDROID_SDK_ROOT"
          export ANDROID_NDK_ROOT="${{ env.ANDROID_NDK }}"
          export ANDROID_SDK_ROOT="$ANDROID_SDK_ROOT"
          
          # 构建前验证源代码
          echo "验证源代码修改..."
          if [ -d "libvlcjni/vlc" ]; then
            VLC_SRC_DIR="libvlcjni/vlc"
            echo "检查core.c修改:"
            if grep -q '"%s abc_media_editor"' "$VLC_SRC_DIR/lib/core.c"; then
              echo "✅ core.c已正确修改"
              # 显示修改的内容
              grep -n '"%s abc_media_editor"' "$VLC_SRC_DIR/lib/core.c"
            else
              echo "❌ core.c未正确修改"
              # 显示问题行
              grep -n 'asprintf.*&str' "$VLC_SRC_DIR/lib/core.c" | head -5
            fi
          fi
          
          # 更新 local.properties
          echo "sdk.dir=$ANDROID_SDK_ROOT" > local.properties
          echo "ndk.dir=$ANDROID_NDK" >> local.properties
      
          echo "开始构建 ARMv7 (armeabi-v7a) 架构..."
          
          # 使用-b参数跳过源码检查
          time ANDROID_NDK="$ANDROID_NDK" ANDROID_SDK="$ANDROID_SDK" \
              ./buildsystem/compile.sh -l -a arm --release -t -b 2>&1 | tee build_armv7.log
      
          if ls libvlcjni/libvlc/build/outputs/aar/*.aar 1> /dev/null 2>&1; then
            echo "✅ ARMv7 AAR 构建成功！"
            cp libvlcjni/libvlc/build/outputs/aar/*.aar ../libvlc-armv7.aar
          else
            echo "❌ 未找到ARMv7 AAR文件。关键错误如下:"
            grep -A 5 -B 5 -i "error\|failed" build_armv7.log | head -100
            exit 1
          fi

      - name: Merge aars and verify
        if: always()
        run: |
          echo "准备合并AAR文件..."
          cd "${{ env.BUILD_DIR }}"
          
          # 查找所有可能生成的AAR文件
          find . -name "*.aar" -type f -exec cp {} ../ \;
          cd ..
          
          echo "找到的AAR文件："
          ls -la *.aar 2>/dev/null || { echo "未找到任何AAR文件，构建可能失败。"; exit 1; }
          
          # 智能合并：自动识别基础包和架构包
          /bin/bash -c '
          aars=(*.aar)
          if [ ${#aars[@]} -lt 1 ]; then
              exit 1
          fi
          # 尝试找到一个包含"all"或版本号最全的作为基础包
          BASE_AAR=""
          for aar in "${aars[@]}"; do
              if [[ "$aar" == *"all"* ]] || [[ "$aar" == *"release"* ]]; then
                  BASE_AAR="$aar"
                  break
              fi
          done
          if [ -z "$BASE_AAR" ]; then
              BASE_AAR="${aars[0]}"
          fi
          
          echo "使用 $BASE_AAR 作为基础包进行合并"
          mkdir -p merged-aar
          unzip -q "$BASE_AAR" -d merged-aar
          
          for aar in "${aars[@]}"; do
              if [ "$aar" != "$BASE_AAR" ]; then
                  echo "合并架构库从: $aar"
                  unzip -q -u "$aar" -d merged-aar 2>/dev/null || true
              fi
          done
          
          cd merged-aar
          zip -qr ../libvlc-release.aar .
          cd ..
          
          echo "✅ 合并完成！最终产物: libvlc-release.aar"
          echo "包含的架构:"
          unzip -l libvlc-release.aar | grep "jni/.*/" | cut -d"/" -f2 | sort -u || echo "无法列出架构"
          '

      - name: Create github release
        uses: softprops/action-gh-release@master
        with:
          tag_name: ${{env.BUILD_DATE}}-vlclib
          files: |
            libvlc-release.aar
            libvlc-arm64.aar
            libvlc-armv7.aar
          draft: false
          prerelease: false

      - name: Push vlc aar to bv-libs repository
        env:
          TARGET_REPO: "git@github.com:zxgv5/bv-libs.git"
        run: |
          # 设置 SSH 密钥和配置
          echo "Setting up SSH configuration..."
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # 写入私钥
          echo "${{ secrets.BV_LIBS_DEPLOY_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          
          # 配置 SSH 不验证主机
          echo "Host github.com" >> ~/.ssh/config
          echo "  StrictHostKeyChecking no" >> ~/.ssh/config
          echo "  UserKnownHostsFile /dev/null" >> ~/.ssh/config
          chmod 600 ~/.ssh/config
          
          # 测试 SSH 连接
          echo "Testing SSH connection to GitHub..."
          ssh -T git@github.com 2>&1 | grep -v "successfully authenticated" || true
          
          # 设置 Git 配置
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git config --global init.defaultBranch main
          
          # 克隆目标仓库
          cd "$GITHUB_WORKSPACE"
          echo "Cloning target repository: ${{ env.TARGET_REPO }}"
          git clone ${{ env.TARGET_REPO }} target-repo
          cd target-repo
          
          # 确保在 main 分支
          git checkout main
          
          # 复制新的 AAR 文件到目标位置
          SOURCE_AAR="$GITHUB_WORKSPACE/libvlc-release.aar"
          TARGET_DIR="libVLC"
          
          # 检查 AAR 文件是否存在
          if [ -f "$SOURCE_AAR" ]; then
            echo "✓ Found AAR file: $SOURCE_AAR"
            
            # 确保目标目录存在
            mkdir -p "$TARGET_DIR"
            
            # 复制新文件
            echo "Copying new AAR file..."
            cp -v "$SOURCE_AAR" "$TARGET_DIR/libvlc-release.aar"
            
            # 提交更改
            echo "Committing changes..."
            git add "$TARGET_DIR/libvlc-release.aar"
            
            # 检查是否有更改
            if git diff --cached --quiet; then
              echo "No changes to commit."
            else
              git commit -m "Update VLC AAR (multi-arch: arm64+v7a) - ${{ env.BUILD_DATE }} [CI]"
              echo "Pushing to remote repository..."
              git push origin main
              echo "✓ Successfully pushed multi-architecture VLC AAR to ${{ env.TARGET_REPO }}"
            fi
          else
            echo "✗ Error: AAR file not found at $SOURCE_AAR"
            exit 1
          fi
          
          # 清理 SSH 密钥
          rm -f ~/.ssh/id_ed25519
          rm -f ~/.ssh/config